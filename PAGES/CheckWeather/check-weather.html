<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather Check</title>
    <link rel="stylesheet" href="../../styles/style.css">
    <link rel="stylesheet" href="../../CometAnimation/comet-animation.css">
    <link id="comet-image-preload" rel="preload" as="image" href="../../CometAnimation/Comet.png">
        <!-- Page-specific styles inlined to keep this page self-contained -->
        <style>
        /* Minimalistic card layout and suggestions dropdown */
        :root{--primary:#224c8e;--muted:#e18f9f}
        body.weather-page{background:linear-gradient(135deg,#f7f9fc,#e8f1ff);}
        .page-content{flex:1 1 auto;display:flex;align-items:center;justify-content:center;padding:2rem 1rem 80px}
        .weather-container{background:rgba(255,255,255,0.98);padding:2rem;border-radius:16px;box-shadow:0 10px 30px rgba(34,76,142,0.08);width:100%;max-width:520px}
        h1{color:var(--primary);margin:0 0 1rem;font-size:1.5rem;text-align:center}
        .search-box{display:flex;gap:.5rem;margin-bottom:0.5rem}
        .search-wrap{position:relative;flex:1}
        #cityInput{width:100%;padding:.75rem 1rem;border:2px solid var(--muted);border-radius:12px;font-size:1rem}
        #cityInput:focus{outline:none;border-color:var(--primary)}
        #searchBtn{padding:.75rem 1.25rem;background:var(--primary);color:#fff;border:none;border-radius:12px;cursor:pointer}
        #searchBtn:disabled{background:#c9d5ea;cursor:not-allowed}
        .suggestions{position:absolute;left:0;right:0;top:100%;background:#fff;border:1px solid #e6eefb;border-radius:8px;margin-top:.5rem;box-shadow:0 8px 20px rgba(34,76,142,0.06);z-index:50;max-height:200px;overflow:auto;padding:0;list-style:none}
        .suggestions li{padding:.6rem .9rem;cursor:pointer;border-bottom:1px solid #f1f6ff}
        .suggestions li:last-child{border-bottom:none}
        .suggestions li:hover,.suggestions li.active{background:#f1f6ff}
        .no-results{padding:.6rem .9rem;color:#777}
        .weather-info{display:none;background:#f7f9fc;padding:1.2rem;border-radius:12px;margin-top:1rem}
    .city-name{display:block;font-size:1.25rem;font-weight:700;color:var(--primary);margin:0.75rem 0 1rem;text-align:center;padding:0 0.5rem}
        .weather-info.visible{display:block}
        .weather-details{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:.75rem;text-align:center}
        .weather-item{padding:.75rem;background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(34,76,142,0.03)}
        .label{color:#666;font-size:.85rem;margin-bottom:.25rem}
        .value{color:var(--primary);font-weight:700;font-size:1.1rem}
        .error-message{display:none;color:#b91c1c;background:#fff0f0;padding:.6rem;border-radius:8px;margin-top:.6rem;text-align:center}
        .error-message.visible{display:block}
        .loading{margin-top:.75rem;text-align:center;color:var(--primary)}
        @media (max-width:480px){.weather-container{padding:1rem;border-radius:12px}.search-box{flex-direction:column}.suggestions{max-height:160px}}
        </style>
</head>
<body class="weather-page">
    <img id="comet-image-src" src="../../CometAnimation/Comet.png" alt="" hidden>
        <!-- Inlined header (previously components/header.html) -->
        <header class="top-nav">
            <div class="top-nav-inner">
                <div class="brand"><a href="https://rajamedindrao.github.io/RajasWebsite/" title="Go to homepage"><img src="../../logo.png" alt="Site logo"></a></div>
                <nav class="nav-links" aria-label="Primary navigation">
                    <a href="check-weather.html" class="nav-pill">Check Weather</a>
                    <a href="../PlayGames/play-games.html" class="nav-pill">Play Games</a>
                    <a href="../TalkWithAI/talk-with-ai.html" class="nav-pill">Talk with AI</a>
                    <a href="../TimerStopWatch/timer-stopwatch.html" class="nav-pill">Timer / Stopwatch</a>
                </nav>
                <button class="nav-toggle" aria-label="Toggle navigation menu">
                    <span></span><span></span><span></span>
                </button>
            </div>
        </header>
        <script>
            (function() {
                const toggle = document.querySelector('.nav-toggle');
                const nav = document.querySelector('.nav-links');
                if (!toggle || !nav) return;
                toggle.addEventListener('click', () => {
                    const isOpen = nav.classList.toggle('is-open');
                    toggle.classList.toggle('is-open', isOpen);
                });
            })();
        </script>
    <div class="page-content">
        <div class="weather-container">
        <h1>Weather Check</h1>
        <div class="search-box">
            <div class="search-wrap">
                <input type="text" id="cityInput" placeholder="Enter city name..." aria-label="City name" autocomplete="off">
                <ul id="suggestions" class="suggestions" hidden></ul>
            </div>
            <button id="searchBtn">Get Weather</button>
        </div>
        <div id="errorMsg" class="error-message"></div>
        <div id="weatherInfo" class="weather-info">
            <div id="cityName" class="city-name"></div>
            <div class="weather-details">
                <div class="weather-item">
                    <div class="label">Temperature</div>
                    <div id="temperature" class="value"></div>
                </div>
                <div class="weather-item">
                    <div class="label">Condition</div>
                    <div id="condition" class="value"></div>
                </div>
                <div class="weather-item">
                    <div class="label">Wind Speed</div>
                    <div id="windSpeed" class="value"></div>
                </div>
                <div class="weather-item">
                    <div class="label">Observed at</div>
                    <div id="observedAt" class="value"></div>
                </div>
                <div class="weather-item">
                    <div class="label">Timezone</div>
                    <div id="tz" class="value"></div>
                </div>
                <div class="weather-item">
                    <div class="label">Elevation</div>
                    <div id="elevation" class="value"></div>
                </div>
            </div>
        </div>

        </div>
    </div>

    <script>
    (function(){
        // Elements
        const cityInput = document.getElementById('cityInput');
        const suggestionsEl = document.getElementById('suggestions');
        const searchBtn = document.getElementById('searchBtn');
        const errorMsg = document.getElementById('errorMsg');
        const weatherInfo = document.getElementById('weatherInfo');
        const cityNameEl = document.getElementById('cityName');
        const temperatureEl = document.getElementById('temperature');
        const conditionEl = document.getElementById('condition');
        const windSpeedEl = document.getElementById('windSpeed');
        const loadingEl = document.createElement('div');
        loadingEl.className = 'loading';
        loadingEl.id = 'loadingIndicator';
        loadingEl.hidden = true;
        loadingEl.textContent = 'Loading...';
        document.querySelector('.weather-container').appendChild(loadingEl);

        // Mapping
        const weatherCodes = {
            0: 'Clear sky',1:'Mainly clear',2:'Partly cloudy',3:'Overcast',45:'Foggy',48:'Depositing rime fog',51:'Light drizzle',53:'Moderate drizzle',55:'Dense drizzle',61:'Slight rain',63:'Moderate rain',65:'Heavy rain',71:'Slight snow',73:'Moderate snow',75:'Heavy snow',77:'Snow grains',80:'Slight rain showers',81:'Moderate rain showers',82:'Violent rain showers',85:'Slight snow showers',86:'Heavy snow showers',95:'Thunderstorm',96:'Thunderstorm with slight hail',99:'Thunderstorm with heavy hail'
        };

        // State
        let selectedCity = null; // {name,country,lat,lon}
        let suggestions = [];
        let highlighted = -1;
        const cache = new Map(); // query -> results

        // Helpers
        function showError(text){ errorMsg.textContent = text; errorMsg.classList.add('visible'); }
        function hideError(){ errorMsg.classList.remove('visible'); }
        function showLoading(){ loadingEl.hidden = false; }
        function hideLoading(){ loadingEl.hidden = true; }

        // Debounce
        function debounce(fn, wait=300){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn.apply(this,args), wait); }; }

        // Fetch suggestions
        async function fetchCities(query){
            if (cache.has(query)) return cache.get(query);
            try{
                const res = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=5`);
                const data = await res.json();
                const results = (data && data.results) ? data.results.slice(0,5) : [];
                cache.set(query, results);
                return results;
            }catch(e){ return null; }
        }

        // Render suggestions
        function renderSuggestions(list){
            suggestionsEl.innerHTML = '';
            highlighted = -1;
            suggestions = list || [];
            if (!suggestions || suggestions.length===0){
                const li = document.createElement('li'); li.className='no-results'; li.textContent='No results found.'; suggestionsEl.appendChild(li); suggestionsEl.hidden=false; return;
            }
            suggestions.forEach((s, idx)=>{
                const li = document.createElement('li');
                li.tabIndex = 0;
                li.textContent = `${s.name}${s.admin1 ? ', ' + s.admin1 : ''}${s.country ? ', ' + s.country : ''}`;
                li.addEventListener('click', ()=>selectSuggestion(idx));
                li.addEventListener('keydown', (e)=>{ if (e.key==='Enter') selectSuggestion(idx); });
                suggestionsEl.appendChild(li);
            });
            suggestionsEl.hidden=false;
        }

        function clearSuggestions(){ suggestionsEl.hidden=true; suggestionsEl.innerHTML=''; suggestions=[]; highlighted=-1; }

        function selectSuggestion(idx){
            const s = suggestions[idx];
            if (!s) return;
            // store extra metadata if present (timezone, elevation)
            selectedCity = { name: s.name, country: s.country, latitude: s.latitude, longitude: s.longitude, timezone: s.timezone, elevation: s.elevation };
            cityInput.value = `${s.name}${s.admin1 ? ', ' + s.admin1 : ''}${s.country ? ', ' + s.country : ''}`;
            clearSuggestions();
            hideError();
        }

        // Keyboard navigation
        function highlightNext(delta){
            const items = suggestionsEl.querySelectorAll('li');
            if (!items.length) return;
            // skip no-results
            if (items[0].classList.contains('no-results')) return;
            highlighted = (highlighted + delta + items.length) % items.length;
            items.forEach((it,i)=> it.classList.toggle('active', i===highlighted));
            // ensure visible
            const el = items[highlighted]; if (el) el.scrollIntoView({block:'nearest'});
        }

        // Handle input
        const onType = debounce(async ()=>{
            const q = cityInput.value.trim();
            selectedCity = null; // reset selection when typing
            // If user is typing a new city (no selection), remove any previously-applied background
            try{ clearBackground(); }catch(e){}
            if (q.length < 2){ clearSuggestions(); return; }
            hideError();
            const list = await fetchCities(q);
            if (list === null){ showError('Unable to fetch suggestions'); return; }
            renderSuggestions(list);
        }, 300);

        cityInput.addEventListener('input', onType);
        cityInput.addEventListener('keydown', (e)=>{
            if (e.key === 'ArrowDown'){ e.preventDefault(); highlightNext(1); }
            else if (e.key === 'ArrowUp'){ e.preventDefault(); highlightNext(-1); }
            else if (e.key === 'Enter'){
                // If suggestion active, select it
                const items = suggestionsEl.querySelectorAll('li');
                if (items.length && highlighted >=0 && !items[0].classList.contains('no-results')){
                    selectSuggestion(highlighted);
                    e.preventDefault();
                    return;
                }
                // Otherwise prevent Enter unless selectedCity matches input
                const cur = cityInput.value.trim();
                if (!selectedCity || !(cur.indexOf(selectedCity.name)===0)){
                    e.preventDefault();
                    showError('Please select a city from the list');
                }
            }
        });

        // Click outside to close suggestions
        document.addEventListener('click', (e)=>{
            if (!e.target.closest('.search-wrap')) clearSuggestions();
        });

        // Get weather
        async function getWeatherForSelected(){
            if (!selectedCity){ showError('Please select a city from the list'); return; }
            hideError();
            weatherInfo.classList.remove('visible');
            showLoading();
            searchBtn.disabled = true;
            try{
                const lat = selectedCity.latitude; const lon = selectedCity.longitude;
                const resp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`);
                const data = await resp.json();
                if (!data || !data.current_weather) throw new Error('Weather data not available');
                const w = data.current_weather;
                cityNameEl.textContent = `${selectedCity.name}${selectedCity.country ? ', ' + selectedCity.country : ''}`;
                temperatureEl.textContent = `${Math.round(w.temperature)}Â°C`;
                conditionEl.textContent = weatherCodes[w.weathercode] || 'Unknown';
                windSpeedEl.textContent = `${Math.round(w.windspeed)} km/h`;
                // observed time: use the current_weather.time (ISO) and show timezone if available
                const observed = w.time || '';
                const tz = data.timezone || selectedCity.timezone || '';
                const elev = (typeof data.elevation !== 'undefined') ? data.elevation : (selectedCity.elevation || '');
                document.getElementById('observedAt').textContent = observed ? new Date(observed).toLocaleString('en-US', { timeZone: tz || undefined }) : '';
                document.getElementById('tz').textContent = tz || '-';
                document.getElementById('elevation').textContent = elev !== '' ? `${elev} m` : '-';
                // Wait for the image/background process to complete (local lookup + optional live fetch + image load)
                try{
                    await tryApplyCityImage(selectedCity);
                }catch(e){ /* swallow - tryApplyCityImage is tolerant */ }
                // Now reveal the weather UI (even if the image failed)
                weatherInfo.classList.add('visible');
            }catch(err){ showError(err.message || 'Unable to fetch weather data');
                // On weather fetch error, ensure any previously-applied background is removed
                try{ clearBackground(); }catch(e){}
            }
            finally{ hideLoading(); searchBtn.disabled = false; }
        }

        searchBtn.addEventListener('click', getWeatherForSelected);

        // initial focus
        cityInput.focus();

        // Ensure .page-content fills the space between header and footer
        function adjustPageContentHeight(){
            try{
                const header = document.querySelector('header.top-nav');
                const footer = document.querySelector('footer');
                const pageContent = document.querySelector('.page-content');
                if (!pageContent) return;
                const winH = window.innerHeight;
                const headerH = header ? header.getBoundingClientRect().height : 0;
                const footerH = footer ? footer.getBoundingClientRect().height : 0;
                const available = Math.max(0, winH - headerH - footerH);
                // set min-height so background covers the area; use px to be precise
                pageContent.style.minHeight = available + 'px';
                // also ensure pageContent uses flex layout to center contents vertically
                pageContent.style.display = 'flex';
                pageContent.style.alignItems = 'center';
                pageContent.style.justifyContent = 'center';
            }catch(e){ /* ignore measurement errors */ }
        }
        // Run on load and resize
        window.addEventListener('load', adjustPageContentHeight);
        window.addEventListener('resize', adjustPageContentHeight);
        // In case header/footer sizes change after DOM mutations, run periodically for a short while
        let _adjustInterval = setInterval(adjustPageContentHeight, 250);
        setTimeout(()=>{ clearInterval(_adjustInterval); }, 3000);

        // --- Wikipedia image lookup and background apply ---
        // In-memory cache: normalized city key -> image URL
        const wikiImageCache = new Map();

        // Normalize keys for lookups (lowercase, trim)
        function normalizeKey(name){ return (name || '').toString().trim().toLowerCase(); }

        // Try to find and apply an image for a selected city.
        // This function is intentionally tolerant: any failure is swallowed so weather UI stays functional.
        async function tryApplyCityImage(city){
            if (!city || !city.name) return;
            const key1 = normalizeKey(city.name);
            const key2 = normalizeKey(`${city.name}${city.country ? ', ' + city.country : ''}`);
            // If cached, apply immediately
            if (wikiImageCache.has(key1)) { await applyBackgroundImageIfLoaded(wikiImageCache.get(key1)); return; }
            if (wikiImageCache.has(key2)) { await applyBackgroundImageIfLoaded(wikiImageCache.get(key2)); return; }

            // Try local files first. Try the single response file, then a multi-entry JSON file.
            const localCandidates = ['./wikipediaResponse.html','./wiki_responses.json','../CheckWeather/wikipediaResponse.html'];
            for (const path of localCandidates){
                try{
                    const res = await fetch(path, {cache: 'no-store'});
                    if (!res.ok) continue;
                    const txt = await res.text();
                    let parsed = null;
                    try{ parsed = JSON.parse(txt); }catch(e){
                        // sometimes .html file may contain JSON only; if parse fails, skip
                        continue;
                    }
                    const entry = findEntryForCity(parsed, key1, key2);
                    if (entry){
                        const img = (entry.originalimage && entry.originalimage.source) ? entry.originalimage.source : (entry.thumbnail && entry.thumbnail.source) ? entry.thumbnail.source : null;
                        if (img) { wikiImageCache.set(key1, img); wikiImageCache.set(key2, img); await applyBackgroundImageIfLoaded(img); return; }
                    }
                }catch(e){ /* ignore and continue */ }
            }

            // Optional live fallback: fetch from Wikipedia REST API (don't persist to disk)
            try{
                const liveRes = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(city.name)}`);
                if (liveRes.ok){
                    const liveJson = await liveRes.json();
                    const img = (liveJson.originalimage && liveJson.originalimage.source) ? liveJson.originalimage.source : (liveJson.thumbnail && liveJson.thumbnail.source) ? liveJson.thumbnail.source : null;
                    if (img){ wikiImageCache.set(key1, img); wikiImageCache.set(key2, img); await applyBackgroundImageIfLoaded(img); return; }
                }
            }catch(e){ /* ignore live fallback errors */ }
        }

        // Find an entry for the city in parsed local wiki data. Supports single object, array, or mapping.
        function findEntryForCity(parsed, key1, key2){
            if (!parsed) return null;
            // If parsed is an array, search items
            if (Array.isArray(parsed)){
                for (const item of parsed){
                    const t = (item.title || item.displaytitle || (item.titles && item.titles.canonical) || '').toString();
                    const nt = normalizeKey(t.replace(/<[^>]+>/g, ''));
                    if (nt === key1 || nt === key2) return item;
                }
                return null;
            }

            // If parsed is an object, it might be either a single summary or a mapping of keys -> entries.
            if (typeof parsed === 'object'){
                // If it looks like a single summary, only return it when the title matches the requested city.
                const titleCandidate = (parsed.title || parsed.displaytitle || (parsed.titles && parsed.titles.canonical) || '').toString();
                const normalizedTitle = normalizeKey(titleCandidate.replace(/<[^>]+>/g, ''));
                if (normalizedTitle && (normalizedTitle === key1 || normalizedTitle === key2)) return parsed;

                // Otherwise, attempt to match keys in the object (treat as a mapping)
                for (const k of Object.keys(parsed)){
                    const nk = normalizeKey(k);
                    if (nk === key1 || nk === key2){ return parsed[k]; }
                }
            }

            return null;
        }

        // Preload image and apply only when loaded (prevents broken bg). If load fails, remove any applied background.
        function clearBackground(){
            const pageContent = document.querySelector('.page-content');
            if (pageContent){
                pageContent.style.backgroundImage = '';
                pageContent.style.backgroundSize = '';
                pageContent.style.backgroundPosition = '';
                pageContent.style.backgroundRepeat = '';
            } else {
                document.body.style.backgroundImage = '';
            }
        }

        // Returns a Promise that resolves when the image loads or rejects on error.
        function applyBackgroundImageIfLoaded(url){
            return new Promise((resolve) => {
                if (!url) return resolve();
                const img = new Image();
                let settled = false;
                img.onload = function(){
                    try{
                        // apply as .page-content background so header/footer remain unaffected
                        const pageContent = document.querySelector('.page-content');
                        if (pageContent){
                            pageContent.style.backgroundImage = `url('${url.replace(/'/g, "\\'")}')`;
                            pageContent.style.backgroundSize = 'cover';
                            pageContent.style.backgroundPosition = 'center center';
                            pageContent.style.backgroundRepeat = 'no-repeat';
                        } else {
                            // fallback to body if .page-content not found
                            document.body.style.backgroundImage = `url('${url.replace(/'/g, "\\'")}')`;
                            document.body.style.backgroundSize = 'cover';
                            document.body.style.backgroundPosition = 'center center';
                            document.body.style.backgroundRepeat = 'no-repeat';
                        }
                    }catch(e){ /* ignore */ }
                    if (!settled){ settled = true; resolve(); }
                };
                img.onerror = function(){
                    try{ clearBackground(); }catch(e){}
                    if (!settled){ settled = true; resolve(); }
                };
                // start loading
                img.src = url;
                // Safety: resolve after a timeout in case onload/onerror never fire (network weirdness)
                setTimeout(()=>{ if (!settled){ settled = true; resolve(); } }, 10000);
            });
        }

    })();
    </script>
        <!-- Inlined footer (previously components/footer.html) -->
        <footer>
            <p>&copy; 2025 Raja Sekhar Medindrao. All rights reserved.</p>
            <p>Licensed under Apache 2.0.</p>
            <p>Developed with Coffee.</p>
        </footer>
    <script src="../../CometAnimation/comet-animation.js"></script>

</body>
</html>
